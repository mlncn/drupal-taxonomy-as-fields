<?php
// $Id: cck.module,v 1.19 2009/07/02 20:31:05 yched Exp $
/**
 * @file
 * Allows administrators to associate custom fields to content types.
 */

/**
 * Implementation of hook_help().
 */
function cck_help($path, $arg) {
  switch ($path) {
    case 'admin/help#cck':
      // TODO Rewrite help to refer to only the appropriate functions and files for the new system.
      return '';
    case 'admin/build/fields':
      return t('The list below shows all fields currently in use for easy reference.');

  }
}

/**
 * Implementation of hook_perm().
 */
function cck_perm() {
  return array(
    // TODO : simplify machine name and update existing perms ?
    'Use PHP input for field settings (dangerous - grant with care)' => array(
      'title' => t('Use PHP input for field settings'),
      'description' => t('Enter PHP code in the field for the field settings that allow it. Warning: Give to trusted roles only; this permission has security implications.'),
    ),
  );
}

/**
 * Implementation of hook_init().
 */
function cck_init() {
  // TODO D7 : be smarter ?
  drupal_add_css(drupal_get_path('module', 'cck') .'/theme/cck.css');
}

/**
 * Implementation of hook_menu_alter().
 */
function cck_menu_alter(&$items) {
  // Customize the content types page with our own callback
  $items['admin/build/types']['page callback'] = 'cck_types_overview';
  $items['admin/build/types']['file'] = 'cck.admin.inc';
  $items['admin/build/types']['file path'] = drupal_get_path('module', 'cck') .'/includes';
}

/**
 * Implementation of hook_menu().
 */
function cck_menu() {
  // Set up menus for both content types and user settings.

  $items = array();
  $items['admin/build/fields'] = array(
    'title' => 'Fields',
    'description' => 'Manage custom fields that have been added to content types or users.',
    'page callback' => 'cck_fields_list',
    'access arguments' => array('administer content types'),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['admin/build/fields/list'] = array(
    'title' => 'Field list',
    'page callback' => 'cck_fields_list',
    'access arguments' => array('administer content types'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 1,
  );
  // TODO D7 : remove, debug code
  $items['admin/build/fields/field-info'] = array(
    'title' => 'Field Info (debug)',
    'page callback' => 'cck_debug_field_info',
    'access arguments' => array('administer content types'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );
  $items['admin/build/types/field-info'] = array(
    'title' => 'Field Info (debug)',
    'page callback' => 'cck_debug_field_info',
    'access arguments' => array('administer content types'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );
  // Create an 'Edit' tab for the user.
  $items['admin/settings/user/edit'] = array(
    'title' => 'Edit',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('user_admin_settings'),
    'access arguments' => array('administer users'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );


  // Make sure this doesn't fire until field_bundles is working,
  // and tables are updated, needed to avoid errors on initial installation.
  if (!defined('MAINTENANCE_MODE')) {
    // Create tabs for all possible bundles.
    foreach (field_info_fieldable_types() as $obj_type => $info) {
      foreach ($info['bundles'] as $bundle_name => $bundle_label) {
        $admin_path = cck_bundle_admin_path($bundle_name);
        $items[$admin_path .'/fields'] = array(
          'title' => 'Manage fields',
          'page callback' => 'drupal_get_form',
          'page arguments' => array('cck_field_overview_form', $bundle_name),
          'access arguments' => array('administer content types'),
          'type' => MENU_LOCAL_TASK,
          'weight' => 1,
        );
        // A dummy function to trigger a page refresh so that
        // field menus get rebuilt correctly when new fields are added.
        $items[$admin_path .'/fields/refresh'] = array(
          'title' => 'Refresh menu',
          'page callback' => 'drupal_get_form',
          'page arguments' => array('cck_field_menu_refresh', $bundle_name),
          'access arguments' => array('administer content types'),
          'type' => MENU_CALLBACK,
          'weight' => 1,
        );
        $items[$admin_path .'/display'] = array(
          'title' => 'Display fields',
          'page callback' => 'drupal_get_form',
          'page arguments' => array('cck_display_overview_form', $bundle_name),
          'access arguments' => array('administer content types'),
          'type' => MENU_LOCAL_TASK,
          'weight' => 2,
        );

        // 'Display fields' tab and context secondary tabs.
        $tabs = cck_build_modes($obj_type);
        foreach ($tabs as $key => $tab) {
          $items[$admin_path .'/display/'. $key] = array(
            'title' => $tab['title'],
            'page arguments' => array('cck_display_overview_form', $bundle_name, $key),
            'access arguments' => array('administer content types'),
            'type' => $key == 'basic' ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
            'weight' => $key == 'basic' ? 0 : 1,
          );
        }

        // Add tabs for any instances that are already created.
        $instances = field_info_instances($bundle_name);
        foreach ($instances as $instance) {
          $field_name = $instance['field_name'];
          $items[$admin_path .'/fields/'. $field_name] = array(
            'title' => $instance['label'],
            'page callback' => 'drupal_get_form',
            'page arguments' => array('cck_field_edit_form', $bundle_name, $field_name),
            'access arguments' => array('administer content types'),
            'type' => MENU_LOCAL_TASK,
          );
          $items[$admin_path .'/fields/'. $field_name .'/edit'] = array(
            'title' => 'Configure instance settings',
            'page callback' => 'drupal_get_form',
            'page arguments' => array('cck_field_edit_form', $bundle_name, $field_name),
            'access arguments' => array('administer content types'),
            'type' => MENU_DEFAULT_LOCAL_TASK,
          );
          $items[$admin_path .'/fields/'. $field_name .'/field-settings'] = array(
            'title' => 'Configure field settings',
            'page callback' => 'drupal_get_form',
            'page arguments' => array('cck_field_settings_form', $bundle_name, $field_name),
            'access arguments' => array('administer content types'),
            'type' => MENU_LOCAL_TASK,
          );
          $items[$admin_path .'/fields/'. $field_name .'/widget-type'] = array(
            'title' => 'Change widget type',
            'page callback' => 'drupal_get_form',
            'page arguments' => array('cck_widget_type_form', $bundle_name, $field_name),
            'access arguments' => array('administer content types'),
            'type' => MENU_LOCAL_TASK,
          );
          $items[$admin_path .'/fields/'. $field_name .'/remove'] = array(
            'title' => 'Remove instance',
            'page callback' => 'drupal_get_form',
            'page arguments' => array('cck_field_remove_form', $bundle_name, $field_name),
            'access arguments' => array('administer content types'),
            'type' => MENU_LOCAL_TASK,
          );
        }
      }
    }
  }
  return $items;
}

function cck_debug_field_info() {
  if (drupal_function_exists('dsm')) {
    module_load_include('inc', 'field', 'field.info');
    dsm(_field_info_collate_types());
    dsm(_field_info_collate_fields());
    return '';
  }
  else {
    return t('You need to enable devel.module to see this page');
  }
}

/**
 * Implementation of hook_theme().
 */
function cck_theme() {
  $path = drupal_get_path('module', 'cck') .'/theme';
  require_once "./$path/theme.inc";

  return array(
    'cck_field_overview_form' => array(
      'template' => 'cck-admin-field-overview-form',
      'path' => $path,
      'arguments' => array('form' => NULL),
    ),
    'cck_display_overview_form' => array(
      'template' => 'cck-admin-display-overview-form',
      'path' => $path,
      'arguments' => array('form' => NULL),
    ),
  );
}

/**
 * Implementation of hook_field_attach_form().
 */
function cck_field_attach_form($obj_type, &$object, &$form, &$form_state) {
  // Add identifier to the object to be used to alter extra fields in the form.
  list($id, $vid, $bundle) = field_attach_extract_ids($obj_type, $object);
  $form['#fieldable'] = TRUE;
  $form['#bundle'] = $bundle;
  $form['#pre_render'][] = 'cck_alter_extra_weights';
  $form['#cck_extra_fields'] = cck_extra_field_values($bundle);
}

/**
 * Implementation of hook_field_attach_view().
 */
function cck_field_attach_view($output, $obj_type, &$object, $teaser) {
  // Add identifier to the object to be used to alter extra fields in the view.
  list($id, $vid, $bundle) = field_attach_extract_ids($obj_type, $object);
  $object->content['#fieldable'] = TRUE;
  $object->content['#bundle'] = $bundle;

  // TODO : doesn't work for user profiles, because template_preprocess_user_profile()
  // uses its own hack to generate separate template variables, and never calls
  // drupal_render() on the whole object. Depending on how this evolves (or not),
  // we might need to move the #pre_render callback on each separate element.
  $object->content['#pre_render'][] = 'cck_alter_extra_weights';
  $object->content['#cck_extra_fields'] = cck_extra_field_values($bundle);

  return $output;
}

/**
 * Implementation of hook_field_attach_pre_insert().
 */
function cck_field_attach_pre_insert($obj_type, &$object) {
  // Add identifier to the object to be used to alter extra fields in the view.
  list($id, $vid, $bundle) = field_attach_extract_ids($obj_type, $object);

  // Implement hook_devel_generate(), if needed.
  if (!empty($object->devel_generate)) {
    include_once('./'. drupal_get_path('module', 'cck') .'/includes/cck.devel.inc');
    cck_generate_fields($object, $bundle);
  }
}

/**
 * Pre-render callback to adjust weights of non-CCK fields.
 */
function cck_alter_extra_weights($elements) {
  if (isset($elements['#cck_extra_fields'])) {
    foreach ($elements['#cck_extra_fields'] as $key => $value) {
      // Some core 'fields' use a different key in node forms and in 'view'
      // render arrays. Check we're not on a form first.
      if (!isset($elements['#build_id']) && isset($value['view']) && isset($elements[$value['view']])) {
        $elements[$value['view']]['#weight'] = $value['weight'];
      }
      elseif (isset($elements[$key])) {
        $elements[$key]['#weight'] = $value['weight'];
      }
    }
  }
  return $elements;
}

/**
 * Implementation of hook_cck_extra_fields.
 */
function cck_cck_extra_fields($bundle_name) {
  if ($bundle_name == 'user') {
    return _cck_user_extra_fields();
  }
  // TODO: we'll need to recognize other non single-mundle fieldable types.
  else {
    return _cck_node_extra_fields($bundle_name);
  }
}

// TODO Add other user elements here.
// How to do this for users? The form elements are totally different
// than the view elements.
function _cck_user_extra_fields() {
  $extra = array();
  $extra['account'] = array(
    'label' => 'User name and password',
    'description' => t('User module form element'),
    'weight' => -10
  );
  $extra['timezone'] = array(
    'label' => 'Timezone',
    'description' => t('User module form element.'),
    'weight' => 6
  );
  $extra['summary'] = array(
    'label' => 'History',
    'description' => t('User module view element.'),
    'weight' => 5
  );
  return $extra;
}

function _cck_node_extra_fields($type_name) {
  $extra = array();
  if ($type = node_type_get_type($type_name)) {
    if ($type->has_title) {
      $extra['title'] = array(
        'label' => $type->title_label,
        'description' => t('Node module element.'),
        'weight' => -5
      );
    }
    $extra['revision_information'] = array(
      'label' => t('Revision information'),
      'description' => t('Node module form.'),
      'weight' => 20
    );
    $extra['author'] = array(
      'label' => t('Authoring information'),
      'description' => t('Node module form.'),
      'weight' => 20
    );
    $extra['options'] = array(
      'label' => t('Publishing options'),
      'description' => t('Node module form.'),
      'weight' => 25
    );
    if (module_exists('comment') && variable_get("comment_$type_name", 2) != 0) {
      $extra['comment_settings'] = array(
        'label' => t('Comment settings'),
        'description' => t('Comment module form.'),
        'weight' => 30
      );
    }
    if (module_exists('locale') && variable_get("language_content_type_$type_name", 0)) {
      $extra['language'] = array(
        'label' => t('Language'),
        'description' => t('Locale module element.'),
        'weight' => 0
      );
    }
    if (module_exists('menu')) {
      $extra['menu'] = array(
        'label' => t('Menu settings'),
        'description' => t('Menu module element.'),
        'weight' => -2
      );
    }
    if (module_exists('taxonomy') && taxonomy_get_vocabularies($type_name)) {
      $extra['taxonomy'] = array(
        'label' => t('Taxonomy'),
        'description' => t('Taxonomy module element.'),
        'weight' => -3
      );
    }
    if (module_exists('book')) {
      $extra['book'] = array(
        'label' => t('Book'),
        'description' => t('Book module element.'),
        'weight' => 10
      );
    }
    if ($type_name == 'poll' && module_exists('poll')) {
      $extra['title'] = array(
        'label' => t('Poll title'),
        'description' => t('Poll module title.'),
        'weight' => -5
      );
      $extra['choice_wrapper'] = array(
        'label' => t('Poll choices'),
        'description' => t('Poll module choices.'),
        'weight' => -4
      );
      $extra['settings'] = array(
        'label' => t('Poll settings'),
        'description' => t('Poll module settings.'),
        'weight' => -3
      );
    }
    if (module_exists('upload') && variable_get("upload_$type_name", TRUE)) {
      $extra['attachments'] = array(
        'label' => t('File attachments'),
        'description' => t('Upload module element.'),
        'weight' => 30,
        'view' => 'files'
      );
    }
  }

  return $extra;
}

/**
 * Retrieve the user-defined weight for non-CCK node 'fields'.
 *
 * CCK's 'Manage fields' page lets users reorder node fields, including non-CCK
 * items (body, taxonomy, other hook_nodeapi-added elements by contrib modules...).
 * Contrib modules that want to have their 'fields' supported need to expose
 * them with hook_cck_extra_fields, and use this function to retrieve the
 * user-defined weight.
 *
 * @param $type_name
 *   The content type name.
 * @param $pseudo_field_name
 *   The name of the 'field'.
 * @return
 *   The weight for the 'field', respecting the user settings stored
 *   by field.module.
 */
function cck_extra_field_weight($bundle_name, $pseudo_field_name) {
  $extra = cck_extra_field_values($bundle_name);
  if (isset($extra[$pseudo_field_name])) {
    return $extra[$pseudo_field_name]['weight'];
  }
}

function cck_extra_field_values($bundle_name) {
  static $info = array();

  if (empty($info)) {
    $info = array();
    $bundles = field_info_bundles();
    foreach ($bundles as $bundle => $bundle_label) {
      // Gather information about non-CCK 'fields'.
      $extra = module_invoke_all('cck_extra_fields', $bundle);
      drupal_alter('cck_extra_fields', $extra, $bundle);

      // Add saved weights.
      foreach (variable_get('cck_extra_weights_'. $bundle, array()) as $key => $value) {
        // Some stored entries might not exist anymore, for instance if uploads
        // have been disabled, or vocabularies removed...
        if (isset($extra[$key])) {
          $extra[$key]['weight'] = $value;
        }
      }
      $info[$bundle] = $extra;
    }
  }
  if (array_key_exists($bundle_name, $info)) {
    return $info[$bundle_name];
  }
  else {
    return array();
  }
}


function cck_build_modes($obj_type, $tab_selector = NULL) {
  static $info;

  if (!isset($info[$obj_type])) {
    $info[$obj_type] = module_invoke_all('cck_build_modes');
    // Collect titles, and filter out non active modes.
    $active_modes = field_build_modes($obj_type);
    foreach ($info[$obj_type] as $tab => $values) {
      $modes = array();
      foreach ($info[$obj_type][$tab]['build modes'] as $mode) {
        if (isset($active_modes[$mode])) {
          $modes[$mode] = $active_modes[$mode];
        }
      }
      if ($modes) {
        $info[$obj_type][$tab]['build modes'] = $modes;
      }
      else {
        unset($info[$obj_type][$tab]);
      }
    }
  }
  if ($tab_selector) {
    return isset($info[$obj_type][$tab_selector]) ? $info[$obj_type][$tab_selector]['build modes'] : array();
  }
  else {
    return $info[$obj_type];
  }
}

/**
 * Implementation of hook_cck_build_modes(), on behalf of other core modules.
 *
 * @return
 * An array describing the build modes defined by the module, grouped by tabs.
 *
 * Expected format:
 * array(
 *   // A module can add its render modes to a tab defined by another module.
 *   'tab1' => array(
 *     'title' => t('The human-readable title of the tab'),
 *     'build modes' => array('mymodule_mode1', 'mymodule_mode2'),
 *   ),
 *   'tab2' => array(
 *     // ...
 *   ),
 * );
 */
function cck_cck_build_modes() {
  $modes = array(
    'basic' => array(
      'title' => t('Basic'),
      'build modes' => array('teaser', 'full'),
    ),
    'rss' => array(
      'title' => t('RSS'),
      'build modes' => array('rss'),
    ),
    'print' => array(
      'title' => t('Print'),
      'build modes' => array('print'),
    ),
    'search' => array(
      'title' => t('Search'),
      'build modes' => array('search_index', 'search_result'),
    ),
  );
  return $modes;
}

/**
 *  Implementation of hook_node_type().
 *
 *  TODO D7: This should be done in hook_field_[create|rename|delete]_bundle().
 */
function cck_node_type($op, $info) {
  switch ($op) {
    case 'insert':
      // TODO Fix this.
      // Trying to get the Manage Fields screen for a new content type to
      // work immediately after the new type is created. Even this won't do it,
      // MF screen is still 'Page not found' after the new type is created.
      menu_rebuild();
      field_cache_clear();
      break;

    case 'update':
      if (isset($info->old_type) && $info->old_type !== $info->type && $extra = variable_get('cck_extra_weights_'. $info->old_type, array())) {
        variable_set('cck_extra_weights_'. $info->type, $extra);
        variable_del('cck_extra_weights_'. $info->old_type);
      }
      break;
    case 'delete':
      variable_del('cck_extra_weights_'. $info->type);
      break;
  }
}

/**
 * Helper function to create the right administration path for a bundle.
 */
function cck_bundle_admin_path($bundle_name) {
  if ($bundle_name == 'user') {
    return 'admin/user/settings';
  }
  else {
    return 'admin/build/node-type/' . str_replace('_', '-', $bundle_name);
  }
}

/**
 * We store all settings in a flat text field, but some settings
 * will be arrays that need to be serialized and unserialized,
 * like the default_value.
 */
function cck_serialized_settings() {
  return array('default_value');
}

/**
 * Helper function to retrieve field settings stored by CCK.
 *
 * CCK uses the 'cck_field_settings' table to store custom settings
 * not used by core.
 *
 * Field settings will have no $instance nor a db bundle column.
 */
function cck_field_get_setting($setting, $setting_type, $field, $instance = NULL) {
  if ($setting_type == 'field' || empty($instance)) {
    $value = db_select('cck_field_settings', 'fs')->fields('fs', array('setting_option'))
      ->condition('fs.setting', $setting)
      ->condition('fs.setting_type', $setting_type)
      ->condition('fs.field_name', $field['field_name'])
      ->execute()->fetchField();
  }
  else {
    $value = db_select('cck_field_settings', 'fs')->fields('fs', array('setting_option'))
      ->condition('fs.setting', $setting)
      ->condition('fs.setting_type', $setting_type)
      ->condition('fs.field_name', $field['field_name'])
      ->condition('fs.bundle', $instance['bundle'])
      ->execute()->fetchField();
  }

  if (in_array($setting, cck_serialized_settings())) {
    $value = unserialize($value);
  }
  return $value;
}

/**
 * Helper function to set field settings stored by CCK.
 *
 * CCK uses the 'cck_field_settings' table to store custom settings
 * not used by core.
 *
 * Field settings will have no $instance nor a db bundle column.
 */
function cck_field_set_setting($setting, $setting_type, $value, $field, $instance = NULL) {
  // Delete any prior values.
  $bundle = ($setting_type == 'field' || empty($instance)) ? NULL : $instance['bundle'];
  if ($setting_type == 'field' || empty($instance)) {
    db_delete('cck_field_settings')
      ->condition('field_name', $field['field_name'])
      ->condition('setting', $setting)
      ->condition('setting_type', $setting_type)
      ->execute();
  }
  else {
    db_delete('cck_field_settings')
      ->condition('field_name', $field['field_name'])
      ->condition('bundle', $bundle)
      ->condition('setting', $setting)
      ->condition('setting_type', $setting_type)
      ->execute();
  }
  // Create the new values.
  if (in_array($setting, cck_serialized_settings())) {
    $value = serialize($value);
  }
  $record = array(
    'field_name' => $field['field_name'],
    'bundle' => $bundle,
    'setting' => $setting,
    'setting_option' => $value,
    'setting_type' => $setting_type,
  );
  $primary_keys = array();
  drupal_write_record('cck_field_settings', $record, $primary_keys);
}

/**
 * Implementation of hook_field_default_value().
 *
 * Helper function to return the correct default value for a field
 * on behalf of fields managed in the CCK UI.
 *
 *  @param $obj_type
 *    The object type.
 *  @param $object
 *    The object.
 *  @param $field
 *    The field array.
 *  @param $instance
 *    The field array.
 *  @return
 *    The default value for that field.
 */
function cck_field_default_value($obj_type, $object, $field, $instance) {
  $default_value = array();
  $default_setting = cck_field_get_setting('default_value', 'instance', $field, $instance);
  $default_setting_php = cck_field_get_setting('default_value_php', 'instance', $field, $instance);
  if (!empty($default_setting_php)) {
    ob_start();
    $result = eval($default_setting_php);
    if (is_array($result)) {
      $default_value = $result;
    }
  }
  elseif (!empty($default_setting)) {
    $default_value = $default_setting;
  }
  return (array) $default_value;
}

/**
 * Helper function to identify inactive fields.
 */
function cck_inactive_fields($type_name = NULL) {
//  module_load_include('inc', 'field', 'includes/field.crud');
//  if (!empty($type_name)) {
//    $param = array('type_name' => $type_name);
//    $inactive = array($type_name => array());
//  }
//  else {
//    $param = array();
//    $inactive = array();
//  }
//  $all = field_field_instance_read($param, TRUE);
//  $active = array_keys(field_fields());
//  foreach ($all as $field) {
//    if (!in_array($field['field_name'], $active)) {
//      $inactive[$field['type_name']][$field['field_name']] = field_field_instance_expand($field);
//    }
//  }
//  if (!empty($type_name)) {
//    return $inactive[$type_name];
//  }
//  return $inactive;
}
