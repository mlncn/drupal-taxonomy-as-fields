<?php
// $Id$

/**
 * @file
 * Defines term field types that can be used with the Options module.
 */

/**
 * Implement hook_theme().
 */
function term_theme() {
  return array(
    'field_formatter_term_default' => array(
      'arguments' => array('element' => NULL),
    ),
    'field_formatter_term_plain' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Implement hook_field_info().
 */
function term_field_info() {
  return array(
    'term' => array(
      'label' => t('Term'),
      'description' => t('This field represents a taxonomy term reference.'),
      'default_widget' => 'options_select',
      'default_formatter' => 'term_default',
      'settings' => array('vid' => 0),
    ),
  );
}

/**
 * Implement hook_field_schema().
 */
function term_field_schema($field) {
  switch ($field['type']) {
    default:
      $columns = array(
        'value' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => FALSE,
        ),
      );
      break;
  }
  return array(
    'columns' => $columns,
    'indexes' => array(
      'value' => array('value'),
    ),
  );
}

/**
 * Implement hook_field_validate().
 *
 * Possible error codes:
 * - 'term_illegal_value': The value is not part of the list of allowed values.
 */
function term_field_validate($obj_type, $object, $field, $instance, $items, &$errors) {
  $allowed_values = term_allowed_values($field);
  foreach ($items as $delta => $item) {
    if (!empty($item['value'])) {
      if (count($allowed_values) && !array_key_exists($item['value'], $allowed_values)) {
        $errors[$field['field_name']][$delta][] = array(
          'error' => 'term_illegal_value',
          'message' => t('%name: illegal value.', array('%name' => t($instance['label']))),
        );
      }
    }
  }
}

/**
 * Implement hook_field_is_empty().
 */
function term_field_is_empty($item, $field) {
  if (empty($item['value']) && (string)$item['value'] !== '0') {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implement hook_field_formatter_info().
 */
function term_field_formatter_info() {
  return array(
    'term_default' => array(
      'label' => t('Link'),
      'field types' => array('term'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
      ),
    ),
    'term_plain' => array(
      'label' => t('Plain text'),
      'field types' => array('term'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
      ),
    ),
  );
}

/**
 * Theme function for 'default' term field formatter.
 */
function theme_field_formatter_term_default($element) {
  $field = field_info_field($element['#field_name']);
  if (($allowed_values = term_allowed_values($field)) && isset($allowed_values[$element['#item']['value']])) {
    $term = taxonomy_term_load($element['#item']['value']);
    return l($term->name, taxonomy_term_path($term));
  }
  // If no match was found in allowed values, fall back to the key.
  return 'invalid - '. $element['#item']['value'];
}

/**
 * Theme function for 'default' term field formatter.
 */
function theme_field_formatter_term_plain($element) {
  $field = field_info_field($element['#field_name']);
  if (($allowed_values = term_allowed_values($field)) && isset($allowed_values[$element['#item']['value']])) {
    $term = taxonomy_term_load($element['#item']['value']);
    return $term->name;
  }
  // If no match was found in allowed values, fall back to the key.
  return 'invalid - '. $element['#item']['value'];
}

/**
 *  Create an array of the allowed values for this field.
 *
 *  Call the allowed_values_function to retrieve the allowed
 *  values array.
 *
 *  This function should imitate the features of _taxonomy_term_select
 *
 *  TODO deal with excluded tids?
 *  TODO support scope limiting to a particular subtree of the vocabulary
 *  TODO support multiple vocabularies in one field
 *  TODO support multiple subtrees of the same or different vocabularies
 *  in one field
 *  TODO access control?
 */
function term_allowed_values($field) {
  $tree = taxonomy_get_tree($field['settings']['vid']);
  $options = array();

  if ($tree) {
    foreach ($tree as $term) {
      $options[$term->tid] = str_repeat('-', $term->depth) . $term->name;
    }
  }
  return $options;
}

/*
 * Implement hook_field_load().
 *
 * This preloads all taxonomy terms for a given object at once using taxonomy_term_load_multiple
 * and unsets values for invalid terms which don't exist.
 */
function term_field_load($obj_type, $objects, $field, $instances, &$items, $age) {
  $tids = array();
  foreach ($objects as $id => $object) {
    foreach ($items[$id] as $delta => $item) {
      $tids[$item['value']] = $item['value'];
    }
  }
  if (count($tids)) {
    $terms = taxonomy_term_load_multiple($tids);
    $missing_tids = array_flip(array_diff_key($tids, $terms));
    if (count($missing_tids)) {
      foreach ($objects as $id => $object) {
        foreach ($items[$id] as $delta => $item) {
          if (array_search($item['value'], $missing_tids)) {
            unset($items[$id][$delta]);
          }
        }
      }
    }
  }
}

/*
 * Implement hook_taxonomy_term_insert().
 */
function term_taxonomy_term_insert($term) {
  _term_clean_field_cache($term);
}

/*
 * Implement hook_taxonomy_term_update().
 */
function term_taxonomy_term_update($term) {
  _term_clean_field_cache($term);
}

function _term_clean_field_cache($term) {
  $fields = field_read_fields(array('type' => 'term'));
  foreach ($fields as $field) {
    if ($field['settings']['vid'] == $term->vid) {
      $objects = field_attach_query($field['field_name'], array(array('value', $term->tid)));
      foreach ($objects as $obj_type => $ids) {
        foreach ($ids as $id) {
          cache_clear_all("field:$obj_type:$id", 'cache_field');
        }
      }
    }
  }
}