<?php
// $Id$

/**
 * @file
 * Defines term field types that can be used with the Options module.
 */

/**
 * Implement hook_theme().
 */
function term_theme() {
  return array(
    'field_formatter_term_default' => array(
      'arguments' => array('element' => NULL),
    ),
    'field_formatter_term_plain' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}

/**
 * Implement hook_field_info().
 */
function term_field_info() {
  return array(
    'term' => array(
      'label' => t('Term'),
      'description' => t('This field represents a taxonomy term reference.'),
      'default_widget' => 'options_select',
      'default_formatter' => 'term_default',
      'settings' => array('vid' => array(0)),
    ),
  );
}

/**
 * Implement hook_field_schema().
 */
function term_field_schema($field) {
  switch ($field['type']) {
    default:
      $columns = array(
        'value' => array(
          'type' => 'int',
          'unsigned' => TRUE,
          'not null' => FALSE,
        ),
      );
      break;
  }
  return array(
    'columns' => $columns,
    'indexes' => array(
      'value' => array('value'),
    ),
  );
}

/**
 * Implement hook_field_validate().
 *
 * Possible error codes:
 * - 'term_illegal_value': The value is not part of the list of allowed values.
 */
function term_field_validate($obj_type, $object, $field, $instance, $items, &$errors) {
  $allowed_values = term_allowed_values($field);
  foreach ($items as $delta => $item) {
    if (!empty($item['value'])) {
      if (count($allowed_values) && !array_key_exists($item['value'], $allowed_values)) {
        $errors[$field['field_name']][$delta][] = array(
          'error' => 'term_illegal_value',
          'message' => t('%name: illegal value.', array('%name' => t($instance['label']))),
        );
      }
    }
  }
}

/**
 * Implement hook_field_is_empty().
 */
function term_field_is_empty($item, $field) {
  if (empty($item['value']) && (string)$item['value'] !== '0') {
    return TRUE;
  }
  return FALSE;
}

/**
 * Implement hook_field_formatter_info().
 */
function term_field_formatter_info() {
  return array(
    'term_default' => array(
      'label' => t('Link'),
      'field types' => array('term'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
      ),
    ),
    'term_plain' => array(
      'label' => t('Plain text'),
      'field types' => array('term'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_DEFAULT,
      ),
    ),
  );
}

/**
 * Theme function for 'default' term field formatter.
 */
function theme_field_formatter_term_default($element) {
  $term = $element['#item']['term'];
  return l($term->name, taxonomy_term_path($term));
}

/**
 * Theme function for 'plain' term field formatter.
 */
function theme_field_formatter_term_plain($element) {
  $term = $element['#item']['term'];
  return $term->name;
}

/**
 *  Create an array of the allowed values for this field.
 *
 *  Call the field's allowed_values function to retrieve the allowed
 *  values array.
 *
 *  This function should imitate the features of _taxonomy_term_select
 *
 *  TODO deal with excluded tids?
 *  TODO support scope limiting to a particular subtree of the vocabulary
 *  TODO support multiple subtrees of the same or different vocabularies in one field
 *  TODO allow values that aren't in a vocabulary if the field/widget/vocabulary (which?) is for
 *  tagging.
 *  TODO the field settings could also enforce some constraints on the user's choosing behavior.
 *  e.g. force user to choose a term with no children, etc.
 */
function term_allowed_values($field) {
  $options = array();
  foreach ($field['settings']['vid'] as $vid) {
    $tree = taxonomy_get_tree($vid);
    if ($tree) {
      foreach ($tree as $term) {
        $options[$term->tid] = str_repeat('-', $term->depth) . $term->name;
      }
    }
  }
  return $options;
}

/*
 * Implement hook_field_load().
 *
 * This preloads all taxonomy terms for a given object at once using taxonomy_term_load_multiple
 * and unsets values for invalid terms which don't exist.
 *
 * @return
 *   array with 'term' object at that index
 */
function term_field_load($obj_type, $objects, $field, $instances, &$items, $age) {
  $tids = array();

  foreach ($objects as $id => $object) {
    foreach ($items[$id] as $delta => $item) {
      $tids[$item['value']] = $item['value'];
    }
  }
  if (count($tids)) {
    $terms = array();
    $query = db_select('taxonomy_term_data', 't');
    $taxonomy_term_data = drupal_schema_fields_sql('taxonomy_term_data');
    $query->fields('t', $taxonomy_term_data);
    $query->condition('t.tid', $tids, 'IN');
    $terms = $query->execute()->fetchAllAssoc('tid');
    foreach ($objects as $id => $object) {
      foreach ($items[$id] as $delta => $item) {
        if (isset($terms[$item['value']])) {
          $items[$id][$delta]['term'] = $terms[$item['value']];
        }
        else {
          unset($items[$id][$delta]);
        }
      }
    }
  }
}

/*
 * Implement hook_taxonomy_term_insert().
 */
function term_taxonomy_term_insert($term) {
  _term_clean_field_cache($term);
}

/*
 * Implement hook_taxonomy_term_update().
 */
function term_taxonomy_term_update($term) {
  _term_clean_field_cache($term);
}

/*
 * Implement hook_taxonomy_term_delete().
 */
function term_taxonomy_term_delete($term) {
  _term_clean_field_cache($term);
}

function _term_clean_field_cache($term) {
  $fields = field_read_fields(array('type' => 'term'));
  foreach ($fields as $field) {
    if ($field['settings']['vid'] == $term->vid) {
      $objects = field_attach_query($field['field_name'], array(array('value', $term->tid)));
      foreach ($objects as $obj_type => $ids) {
        foreach ($ids as $id) {
          cache_clear_all("field:$obj_type:$id", 'cache_field');
        }
      }
    }
  }
}