<?php
// $Id$
/**
 * @file
 * Allows administrators to associate custom fields to fieldable types.
 */

/**
 * Implement hook_help().
 */
function field_ui_help($path, $arg) {
  switch ($path) {
    case 'admin/help#field_ui':
       $output = '';
       $output .= '<p>' . t('The Field UI module provides an administrative interface for adding custom fields to content types, users, comments, and other types of data. In the case of content types, a few fields are provided by default, such as the "Summary and Body" field. The Field UI module lets you modify or remove the default fields attached to content, as well as create your own fields for storing any additional information. Field configuration is accessible through tabs on the <a href="@content-types">content types administration page</a>. (See the <a href="@node-help">node module help page</a> for more information about content types.)', array('@content-types' => url('admin/content/types'), '@node-help' => url('admin/help/node'))) . '</p>';
       $output .= '<p>' . t('When adding a custom field to a content type, you determine its type (whether it will contain text, numbers, lists, etc.) and how it will be displayed (either as a text field or text area, a select box, checkboxes, radio buttons, or an auto-complete text field). A field may have multiple values (i.e., a "person" may have multiple e-mail addresses) or a single value (i.e., an "employee" has a single employee identification number).') . '</p>';
       $output .= '<p>' . t('Custom field types may be provided by additional modules. Drupal core includes the following field types:') . '</p>';
       $output .= '<ul>';
       $output .= '<li>' . t('<em>Number</em>: Adds numeric field types, in integer, decimal or floating point form. You may define a set of allowed inputs, or specify an allowable range of values. A variety of common formats for displaying numeric data are available.') . '</li>';
       $output .= '<li>' . t("<em>Text</em>: Adds text field types. A text field may contain plain text only, or optionally, may use Drupal's input format filters to securely manage HTML output. Text input fields may be either a single line (text field), multiple lines (text area), or for greater input control, a select box, checkbox, or radio buttons. If desired, CCK can validate the input to a set of allowed values.") . '</li>';
       $output .= '<li>' . t('<em>List</em>: Provides storage mechanisms to store a list of items. Usually these items are input through a select list, checkboxes, or radio buttons.') . '</li>';
       $output .= '</ul>';
      return $output;
    case 'admin/build/fields':
      return t('The list below shows all fields currently in use for easy reference.');
  }
}

/**
 * Implement hook_menu().
 */
function field_ui_menu() {
  $items['admin/structure/fields'] = array(
    'title' => 'Fields',
    'description' => 'Overview of fields on all object types.',
    'page callback' => 'field_ui_fields_list',
    'access arguments' => array('administer content types'),
    'type' => MENU_NORMAL_ITEM,
  );

  // Make sure this doesn't fire until field_bundles is working, and tables are
  // updated, needed to avoid errors on initial installation.
  if (!defined('MAINTENANCE_MODE')) {
    // Create tabs for all possible bundles.
    foreach (field_info_fieldable_types() as $obj_type => $info) {
      foreach ($info['bundles'] as $bundle_name => $bundle_info) {
        if (isset($bundle_info['admin'])) {
          // Extract informations from the bundle description.
          $path = $bundle_info['admin']['path'];
          $bundle_arg = isset($bundle_info['admin']['bundle argument']) ? $bundle_info['admin']['bundle argument'] : $bundle_name;
          $access = array_intersect_key($bundle_info['admin'], drupal_map_assoc(array('access callback', 'access arguments')));

          $items["$path/fields"] = array(
            'title' => 'Manage fields',
            'page callback' => 'drupal_get_form',
            'page arguments' => array('field_ui_field_overview_form', $obj_type, $bundle_arg),
            'type' => MENU_LOCAL_TASK,
            'weight' => 1,
          ) + $access;
          // A dummy function to trigger a page refresh so that field menus get
          // rebuilt correctly when new fields are added.
          $items["$path/fields/refresh"] = array(
            'title' => 'Refresh menu',
            'page callback' => 'field_ui_field_menu_refresh',
            'page arguments' => array($obj_type, $bundle_arg),
            'type' => MENU_CALLBACK,
            'weight' => 1,
          ) + $access;
          $items["$path/display"] = array(
            'title' => 'Display fields',
            'page callback' => 'drupal_get_form',
            'page arguments' => array('field_ui_display_overview_form', $obj_type, $bundle_arg),
            'type' => MENU_LOCAL_TASK,
            'weight' => 2,
          ) + $access;

          // 'Display fields' tab and context secondary tabs.
          $tabs = field_ui_build_modes_tabs($obj_type);
          foreach ($tabs as $key => $tab) {
            $items["$path/display/$key"] = array(
              'title' => $tab['title'],
              'page arguments' => array('field_ui_display_overview_form', $obj_type, $bundle_arg, $key),
              'type' => $key == 'basic' ? MENU_DEFAULT_LOCAL_TASK : MENU_LOCAL_TASK,
              'weight' => $key == 'basic' ? 0 : 1,
            ) + $access;
          }

          // Add tabs for any instances that are already created.
          $instances = field_info_instances($bundle_name);
          foreach ($instances as $instance) {
            $field_name = $instance['field_name'];
            $items["$path/fields/$field_name"] = array(
              'title' => $instance['label'],
              'page callback' => 'drupal_get_form',
              'page arguments' => array('field_ui_field_edit_form', $obj_type, $bundle_arg, $field_name),
              'type' => MENU_LOCAL_TASK,
            ) + $access;
            $items["$path/fields/$field_name/edit"] = array(
              'title' => 'Configure instance settings',
              'page callback' => 'drupal_get_form',
              'page arguments' => array('field_ui_field_edit_form', $obj_type, $bundle_arg, $field_name),
              'type' => MENU_DEFAULT_LOCAL_TASK,
            ) + $access;
            $items["$path/fields/$field_name/field-settings"] = array(
              'title' => 'Configure field settings',
              'page callback' => 'drupal_get_form',
              'page arguments' => array('field_ui_field_settings_form', $obj_type, $bundle_arg, $field_name),
              'type' => MENU_LOCAL_TASK,
            ) + $access;
            $items["$path/fields/$field_name/widget-type"] = array(
              'title' => 'Change widget type',
              'page callback' => 'drupal_get_form',
              'page arguments' => array('field_ui_widget_type_form', $obj_type, $bundle_arg, $field_name),
              'type' => MENU_LOCAL_TASK,
            ) + $access;
            $items["$path/fields/$field_name/remove"] = array(
              'title' => 'Remove instance',
              'page callback' => 'drupal_get_form',
              'page arguments' => array('field_ui_field_remove_form', $obj_type, $bundle_arg, $field_name),
              'type' => MENU_LOCAL_TASK,
            ) + $access;
          }
        }
      }
    }
  }
  return $items;
}

/**
 * Implement hook_theme().
 */
function field_ui_theme() {
  return array(
    'field_ui_field_overview_form' => array(
      'arguments' => array('form' => NULL),
      'file' => 'field_ui.pages.inc',
      'template' => 'field_ui-field-overview-form',
    ),
    'field_ui_display_overview_form' => array(
      'arguments' => array('form' => NULL),
      'file' => 'field_ui.pages.inc',
      'template' => 'field_ui-display-overview-form',
    ),
  );
}

/**
 * Pre-render callback to adjust weights of non-field elements on objects.
 *
 * @todo Move this to field.module.
 */
function field_ui_alter_extra_weights($elements) {
  if (isset($elements['#extra_fields'])) {
    foreach ($elements['#extra_fields'] as $key => $value) {
      // Some core 'fields' use a different key in node forms and in 'view'
      // render arrays. Check we're not on a form first.
      if (!isset($elements['#build_id']) && isset($value['view']) && isset($elements[$value['view']])) {
        $elements[$value['view']]['#weight'] = $value['weight'];
      }
      elseif (isset($elements[$key])) {
        $elements[$key]['#weight'] = $value['weight'];
      }
    }
  }
  return $elements;
}

/**
 * Retrieve the user-defined weight for pseudo-field components.
 *
 * @param $bundle_name
 *   The bundle name.
 * @param $pseudo_field_name
 *   The name of the 'field'.
 * @return
 *   The weight for the 'field', respecting the user settings stored
 *   by field.module.
 */
function field_ui_extra_field_weight($bundle_name, $pseudo_field_name) {
  $extra = field_ui_extra_field_values($bundle_name);
  if (isset($extra[$pseudo_field_name])) {
    return $extra[$pseudo_field_name]['weight'];
  }
}

/**
 * Collect the list of pseudo-field components in a given bundle.
 *
 * @param $bundle_name
 *   The bundle name.
 * @return
 *   The array of pseudo-field elements in the bundle.
 */
function field_ui_extra_field_values($bundle_name) {
  $info = &drupal_static(__FUNCTION__, array());

  if (empty($info)) {
    $info = array();
    $bundles = field_info_bundles();
    foreach ($bundles as $bundle => $bundle_label) {
      // Gather information about non-field object additions.
      $extra = module_invoke_all('field_ui_extra_fields', $bundle);
      drupal_alter('field_ui_extra_fields', $extra, $bundle);

      // Add saved weights.
      foreach (variable_get("field_extra_weights_$bundle", array()) as $key => $value) {
        // Some stored entries might not exist anymore, for instance if uploads
        // have been disabled, or vocabularies removed...
        if (isset($extra[$key])) {
          $extra[$key]['weight'] = $value;
        }
      }
      $info[$bundle] = $extra;
    }
  }
  if (array_key_exists($bundle_name, $info)) {
    return $info[$bundle_name];
  }
  else {
    return array();
  }
}

/**
 * Group available build modes on tabs on the 'Display fields' page.
 *
 * @todo Remove this completely and use vertical tabs?
 */
function field_ui_build_modes_tabs($obj_type, $tab_selector = NULL) {
  $info = &drupal_static(__FUNCTION__);

  if (!isset($info[$obj_type])) {
    $info[$obj_type] = module_invoke_all('field_ui_build_modes_tabs');
    // Collect titles, and filter out non active modes.
    $active_modes = field_build_modes($obj_type);
    foreach ($info[$obj_type] as $tab => $values) {
      $modes = array();
      foreach ($info[$obj_type][$tab]['build modes'] as $mode) {
        if (isset($active_modes[$mode])) {
          $modes[$mode] = $active_modes[$mode];
        }
      }
      if ($modes) {
        $info[$obj_type][$tab]['build modes'] = $modes;
      }
      else {
        unset($info[$obj_type][$tab]);
      }
    }
  }
  if ($tab_selector) {
    return isset($info[$obj_type][$tab_selector]) ? $info[$obj_type][$tab_selector]['build modes'] : array();
  }
  else {
    return $info[$obj_type];
  }
}

/**
 * Implement hook_field_ui_build_modes_tabs(), on behalf of other core modules.
 *
 * @return
 * An array describing the build modes defined by the module, grouped by tabs.
 *
 * Expected format:
 * array(
 *   // A module can add its render modes to a tab defined by another module.
 *   'tab1' => array(
 *     'title' => t('The human-readable title of the tab'),
 *     'build modes' => array('mymodule_mode1', 'mymodule_mode2'),
 *   ),
 *   'tab2' => array(
 *     // ...
 *   ),
 * );
 */
function field_ui_field_ui_build_modes_tabs() {
  $modes = array(
    'basic' => array(
      'title' => t('Basic'),
      'build modes' => array('teaser', 'full'),
    ),
    'rss' => array(
      'title' => t('RSS'),
      'build modes' => array('rss'),
    ),
    'print' => array(
      'title' => t('Print'),
      'build modes' => array('print'),
    ),
    'search' => array(
      'title' => t('Search'),
      'build modes' => array('search_index', 'search_result'),
    ),
  );
  return $modes;
}

/**
 * The Field API doesn't allow field updates, so we create a method here to
 * update field if no data is created yet.
 *
 * @see field_create_field()
 */
function field_ui_update_field($field) {
  $field_types = field_info_field_types();
  $module = $field_types[$field['type']]['module'];

  $defaults = field_info_field_settings($field['type']);
  $field['settings'] = array_merge($defaults, (array) $field['settings']);
  $data = $field;
  unset($data['id'], $data['columns'], $data['field_name'], $data['type'], $data['locked'], $data['module'], $data['cardinality'], $data['active'], $data['deleted']);
  $field['data'] = $data;

  drupal_write_record('field_config', $field, array('field_name'));

  // Clear caches
  field_cache_clear(TRUE);
}

/**
 * Implement hook_field_attach_create_bundle().
 */
function field_ui_field_attach_create_bundle($bundle) {
  // TODO: Fix this.
  // Trying to get the Manage Fields screen for a new content type to
  // work immediately after the new type is created. Even this won't do it,
  // MF screen is still 'Page not found' after the new type is created.
  menu_rebuild();
  field_cache_clear();
}

/**
 * Implement hook_field_attach_rename_bundle().
 */
function field_ui_field_attach_rename_bundle($bundle_old, $bundle_new) {
  if ($bundle_old !== $bundle_new && $extra = variable_get("field_extra_weights_$bundle_old", array())) {
    variable_set("field_extra_weights_$bundle_new", $extra);
    variable_del("field_extra_weights_$bundle_old");
  }
}

/**
 * Implement hook_field_attach_delete_bundle().
 */
function field_ui_field_attach_delete_bundle($bundle) {
  variable_del('field_extra_weights_' . $bundle);
}

/**
 * Helper function to create the right administration path for a bundle.
 */
function _field_ui_bundle_admin_path($bundle_name) {
  $bundles = field_info_bundles();
  $bundle_info = $bundles[$bundle_name];
  return isset($bundle_info['admin']['real path']) ? $bundle_info['admin']['real path'] : $bundle_info['admin']['path'];
}

/**
 * Helper function to identify inactive fields within a bundle.
 */
function field_ui_inactive_instances($bundle_name = NULL) {
  if (!empty($bundle_name)) {
    $inactive = array($bundle_name => array());
    $params = array('bundle' => $bundle_name);
  }
  else {
    $inactive = array();
    $params = array();
  }
  $active_instances = field_info_instances();
  $all_instances = field_read_instances($params, array('include_inactive' => TRUE));
  foreach ($all_instances as $instance) {
    if (!isset($active_instances[$instance['bundle']][$instance['field_name']])) {
      $inactive[$instance['bundle']][$instance['field_name']] = $instance;
    }
  }
  if (!empty($bundle_name)) {
    return $inactive[$bundle_name];
  }
  return $inactive;
}
